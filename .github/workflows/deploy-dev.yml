name: Build, Push, and Deploy (versioned, compose-aware)

on:
  push:
    branches: ["develop"]
  workflow_dispatch:

env:
  IMAGE_NAME: freelixlaos/freelix-backend   # Docker Hub repo
  DEPLOY_PATH: /opt/freelix-backend         # server folder that already has docker-compose.yml
  SERVICE_NAME: freelix-backend             # compose service/container name for backend

jobs:
  build-and-push:
    name: Build & Push Docker image
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      VERSION: ${{ steps.pkg.outputs.VERSION }}
      IMAGE_TAG: ${{ steps.pkg.outputs.IMAGE_TAG }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node (for reading package.json)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Read version (fallback to latest)
        id: pkg
        shell: bash
        run: |
          set -euo pipefail
          VERSION=""
          if [ -f package.json ]; then
            VERSION=$(node -e "try{console.log(require('./package.json').version||'')}catch(e){console.log('')}")
          fi
          if [ -z "$VERSION" ]; then
            VERSION="latest"
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="v${VERSION}"
          fi
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "Resolved VERSION=$VERSION IMAGE_TAG=$IMAGE_TAG"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.IMAGE_NAME }}:${{ steps.pkg.outputs.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server (update compose backend only)
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      # Fail early if essential secrets are missing
      - name: Validate required secrets
        if: ${{ secrets.SSH_HOST == '' || secrets.SSH_USER == '' || secrets.SSH_PASSWORD == '' || secrets.DOCKERHUB_USERNAME == '' || secrets.DOCKERHUB_TOKEN == '' }}
        run: |
          echo "::error::Missing required secrets. Set SSH_HOST, SSH_USER, SSH_PASSWORD, DOCKERHUB_USERNAME, DOCKERHUB_TOKEN."
          exit 1

      - name: Deploy via SSH (handles sudo without TTY)
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.IMAGE_TAG }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}         # used as fallback for sudo
          SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}       # optional; if unset, SSH_PASSWORD is used
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          password: ${{ secrets.SSH_PASSWORD }}
          # Uncomment if you use a non-default SSH port:
          # port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 20m
          # Pass env vars into the remote shell
          envs: IMAGE_NAME,IMAGE_TAG,DEPLOY_PATH,SERVICE_NAME,DOCKERHUB_USERNAME,DOCKERHUB_TOKEN,SSH_PASSWORD,SUDO_PASSWORD
          script: |
            set -euo pipefail

            # Choose a sudo password: prefer SUDO_PASSWORD, else SSH_PASSWORD
            SUDO_PASS="${SUDO_PASSWORD:-$SSH_PASSWORD}"

            # If we're root, no sudo needed; otherwise require a password for sudo -S
            if [ "$(id -u)" -eq 0 ]; then
              echo "[INFO] Running as root on remote host."
              ROOT_PREFIX=""
            else
              if [ -z "${SUDO_PASS:-}" ]; then
                echo "::error::This user requires sudo but no sudo password was provided. Set secret SUDO_PASSWORD or run as root / add user to docker group."
                exit 1
              fi
              echo "[INFO] Authenticating sudo..."
              echo "$SUDO_PASS" | sudo -S -v
              ROOT_PREFIX="sudo -S"
            fi

            # Helper to run a whole privileged block (either with sudo or directly)
            run_root_block() {
              # shellcheck disable=SC2016
              CMD=$1
              if [ -z "$ROOT_PREFIX" ]; then
                bash -lc "$CMD"
              else
                # feed sudo password via stdin one time for the whole block
                echo "$SUDO_PASS" | $ROOT_PREFIX bash -lc "$CMD"
              fi
            }

            # Build the privileged deployment script
            read -r -d '' PRIV_BLOCK <<'EOS'
              set -euo pipefail

              # Ensure docker installed and compose v2 available
              if ! command -v docker >/dev/null 2>&1; then
                echo "docker not found on server"; exit 1
              fi
              if ! docker compose version >/dev/null 2>&1; then
                echo "docker compose v2 not found"; exit 1
              fi

              # Docker Hub login using a temp file (avoids stdin conflict with sudo -S)
              umask 077
              printf '%s' "$DOCKERHUB_TOKEN" > /root/.dhtoken
              docker login -u "$DOCKERHUB_USERNAME" --password-stdin < /root/.dhtoken
              rm -f /root/.dhtoken

              mkdir -p "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"

              if [ ! -f docker-compose.yml ]; then
                echo "docker-compose.yml not found in $DEPLOY_PATH â€” aborting."; exit 1
              fi

              echo "Current compose services:"
              docker compose config --services || true

              # ensure backend network exists (optional)
              docker network inspect backend >/dev/null 2>&1 || docker network create backend

              # Update ONLY backend image line
              sed -i -E "s|(^[[:space:]]*image:[[:space:]]*)${IMAGE_NAME}:[[:alnum:]._-]+|\1${IMAGE_NAME}:${IMAGE_TAG}|g" docker-compose.yml

              echo "Compose diff (around image):"
              grep -n -A2 -B2 -E "image:.*${IMAGE_NAME}" docker-compose.yml || true

              echo "Pull the new backend image..."
              docker pull "${IMAGE_NAME}:${IMAGE_TAG}"

              echo "Waiting for MySQL healthy (max ~90s)..."
              ATTEMPTS=0
              until [ "$(docker inspect --format='{{json .State.Health.Status}}' mysql-prod 2>/dev/null | tr -d '\"')" = "healthy" ] || [ $ATTEMPTS -ge 9 ]; do
                ATTEMPTS=$((ATTEMPTS+1))
                sleep 10
              done

              echo "Recreate only backend with the new image..."
              docker compose pull "${SERVICE_NAME}"
              docker compose up -d "${SERVICE_NAME}"

              echo "Prune dangling images..."
              docker image prune -f

              echo "Status:"
              docker ps --filter "name=${SERVICE_NAME}" || true
              docker compose ps || true

              echo "Recent backend logs (30 lines):"
              docker logs --tail=30 "${SERVICE_NAME}" || true
EOS

            # Execute the privileged block (with sudo -S if needed)
            run_root_block "$PRIV_BLOCK"
