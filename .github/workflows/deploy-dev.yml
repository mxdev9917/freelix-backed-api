name: Build, Push, and Deploy (versioned, compose-aware)

on:
  push:
    branches: ["develop"]
  workflow_dispatch:

env:
  IMAGE_NAME: freelixlaos/freelix-backend   # Docker Hub repo
  DEPLOY_PATH: /opt/freelix-backend         # server folder that already has docker-compose.yml
  SERVICE_NAME: freelix-backend             # compose service/container name for backend

jobs:
  build-and-push:
    name: Build & Push Docker image
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      VERSION: ${{ steps.pkg.outputs.VERSION }}
      IMAGE_TAG: ${{ steps.pkg.outputs.IMAGE_TAG }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node (for reading package.json)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Read version (fallback to latest)
        id: pkg
        shell: bash
        run: |
          set -euo pipefail
          VERSION=""
          if [ -f package.json ]; then
            VERSION=$(node -e "try{console.log(require('./package.json').version||'')}catch(e){console.log('')}")
          fi
          if [ -z "$VERSION" ]; then
            VERSION="latest"
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="v${VERSION}"
          fi
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "Resolved VERSION=$VERSION IMAGE_TAG=$IMAGE_TAG"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.IMAGE_NAME }}:${{ steps.pkg.outputs.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server (update compose backend only)
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Deploy via SSH (password) - compose-aware with sudo/FS sudo fallback
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.IMAGE_TAG }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}            # ใช้ prime sudo
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          # IMAGE_NAME, DEPLOY_PATH, SERVICE_NAME มาจาก env ด้านบน
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          password: ${{ secrets.SSH_PASSWORD }}
          # ถ้าใช้พอร์ตไม่ใช่ 22 ให้สร้าง SSH_PORT แล้วค่อย uncomment
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 20m
          envs: IMAGE_NAME,IMAGE_TAG,DEPLOY_PATH,SERVICE_NAME,SSH_PASSWORD,DOCKERHUB_USERNAME,DOCKERHUB_TOKEN
          script: |
            set -euo pipefail

            # ---------- Decide SUDO for Docker ----------
            if docker info >/dev/null 2>&1; then
              echo "Docker accessible without sudo."
              SUDO=""
            else
              echo "Docker requires sudo; priming sudo..."
              printf "%s\n" "$SSH_PASSWORD" | sudo -S -p "" true
              SUDO="sudo"
            fi

            # ---------- Decide FSUDO for filesystem (/opt needs root) ----------
            FSUDO=""
            PARENT_DIR="$(dirname "$DEPLOY_PATH")"
            # ถ้า dir มีอยู่แล้ว ตรวจสิทธิ์เขียน; ถ้ายังไม่มี ตรวจสิทธิ์ที่ parent
            if [ -d "$DEPLOY_PATH" ]; then
              if [ ! -w "$DEPLOY_PATH" ]; then
                [ -z "$SUDO" ] && printf "%s\n" "$SSH_PASSWORD" | sudo -S -p "" true
                FSUDO="sudo"
              fi
            else
              if [ ! -w "$PARENT_DIR" ]; then
                [ -z "$SUDO" ] && printf "%s\n" "$SSH_PASSWORD" | sudo -S -p "" true
                FSUDO="sudo"
              fi
            fi

            echo "Login Docker Hub (using --password-stdin)..."
            printf '%s' "$DOCKERHUB_TOKEN" | $SUDO docker login -u "$DOCKERHUB_USERNAME" --password-stdin

            echo "Ensure deploy path..."
            $FSUDO mkdir -p "$DEPLOY_PATH"

            echo "Ensure docker-compose.yml exists..."
            if ! $FSUDO test -f "$DEPLOY_PATH/docker-compose.yml"; then
              echo "docker-compose.yml not found in $DEPLOY_PATH — aborting."
              exit 1
            fi

            echo "Current compose services:"
            $SUDO docker compose -f "$DEPLOY_PATH/docker-compose.yml" config --services || true

            # OPTIONAL: ensure network exists
            $SUDO docker network inspect backend >/dev/null 2>&1 || $SUDO docker network create backend

            echo "Update only backend image tag inside compose..."
            $FSUDO sed -i -E "s|(^[[:space:]]*image:[[:space:]]*)${IMAGE_NAME}:[[:alnum:]._-]+|\1${IMAGE_NAME}:${IMAGE_TAG}|g" "$DEPLOY_PATH/docker-compose.yml"

            echo "Compose diff (context around image):"
            $FSUDO grep -n -A2 -B2 -E "image:.*${IMAGE_NAME}" "$DEPLOY_PATH/docker-compose.yml" || true

            echo "Pull new backend image..."
            $SUDO docker pull "${IMAGE_NAME}:${IMAGE_TAG}"

            echo "Wait for MySQL healthy (best effort, ~90s max)..."
            ATTEMPTS=0
            until [ "$($SUDO docker inspect --format='{{json .State.Health.Status}}' mysql-prod 2>/dev/null | tr -d '"')" = "healthy" ] || [ $ATTEMPTS -ge 9 ]; do
              ATTEMPTS=$((ATTEMPTS+1))
              sleep 10
            done

            echo "Recreate only backend with the new image..."
            $SUDO docker compose -f "$DEPLOY_PATH/docker-compose.yml" pull "${SERVICE_NAME}"
            $SUDO docker compose -f "$DEPLOY_PATH/docker-compose.yml" up -d "${SERVICE_NAME}"

            echo "Prune dangling images..."
            $SUDO docker image prune -f

            echo "Status:"
            $SUDO docker ps --filter "name=${SERVICE_NAME}" || true
            $SUDO docker compose -f "$DEPLOY_PATH/docker-compose.yml" ps || true

            echo "Recent backend logs (30 lines):"
            $SUDO docker logs --tail=30 "${SERVICE_NAME}" || true
